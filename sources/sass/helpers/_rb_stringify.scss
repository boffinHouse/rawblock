@function rbEscapeQuotes($string, $prepend: '') {
	$newstring: $string;
	$length: str_length($string);
	$index: str_index($string, '"');

	@if $index and $index > 0 {
		@if $prepend == '' {
			@warn 'doubble quote found in "' + $string + '" will convert to single quote.';
		}
		$prepend: str_slice($string, 0, $index - 1) + "'";
		$newstring: rbEscapeQuotes((str_slice($string, $index + 1, $length + 1)), $prepend);
	}

	@return $prepend + $newstring;
}

@function rbToJSON($data) {
	$string: "";
	$type: type-of($data);

	@if type-of($data) == 'color' {
		$data: inspect($data);
		$type: 'string';
	}

	@if $type == "map" {
		$string: $string + "{";

		@each $key, $value in $data {
			$string: $string + '"' + $key + '":' + rbToJSON($value) +',';
		}

		$string: str-slice($string, 0, str-length($string) - 1) + '}';
	}
	@else if $type == "list" {
		$string: $string + "[";

		@for $i from 1 through length($data) {
			$string: $string + rbToJSON(nth($data, $i)) +',';
		}

		$string: str-slice($string, 0, str-length($string) - 1)  + ']';
	}
	@else if $type == "number" {
		$string: $string + $data;
	}
	@else if type-of($data) == "string" {
		$string: $string + ' "' + rbEscapeQuotes($data) + '"';
	} @else if $type == "bool" {
		$string: $string + $data;
	} @else {
		$string: $string + 'null';
	}

	@return $string;
}

@mixin exportToJS($data){
	&::before {
		$string: rbToJSON($data);
		content: $string !important;
		visibility: hidden !important;
		display: block !important;
		height: 0 !important;
	}
}
